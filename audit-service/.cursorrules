# Audit Service - Cursor Intelligence

## Service Overview
Go-based microservice providing read-only access to audit logs for PowerPoint translation sessions. Uses Gin framework, Zap logging, JWT validation with caching, and Supabase REST API.

## Critical Implementation Paths

### Authentication Flow
1. Extract token from Authorization header (Bearer) or share_token query param
2. Check token cache first (5min TTL for JWT, 1min for share tokens)
3. Validate JWT locally using Supabase JWT secret
4. For share tokens, query session_shares table via Supabase REST
5. Cache successful validations

### Supabase REST Integration
- Use service role key for all requests
- Base URL: `{SUPABASE_URL}/rest/v1`
- Required headers:
  - `apikey: {SUPABASE_SERVICE_ROLE_KEY}`
  - `Authorization: Bearer {SUPABASE_SERVICE_ROLE_KEY}`
  - `Prefer: count=exact` (for pagination)

### Error Handling Pattern
- Return domain errors from service layer
- Convert to HTTP errors in handler layer
- Never expose internal error details to clients
- Log full errors with request ID for debugging

## Code Style & Patterns

### Go Conventions
- Use idiomatic Go patterns
- Prefer composition over inheritance
- Return early for error conditions
- Use context for cancellation and timeouts
- Table-driven tests for comprehensive coverage

### Project Structure
```
internal/          # Private packages
  domain/         # Business entities
  handlers/       # HTTP handlers
  service/        # Business logic
  repository/     # Data access
  middleware/     # HTTP middleware
  config/         # Configuration

pkg/              # Public packages
  cache/         # Token caching
  jwt/           # JWT validation
```

### Naming Conventions
- Interfaces: suffix with behavior (e.g., `AuditRepository`, `TokenValidator`)
- Constructors: `NewXxx` pattern
- Test files: `xxx_test.go` in same package
- Mock files: `mock_xxx.go` generated by mockery

### Dependency Injection
```go
// Constructor injection pattern
type AuditService struct {
    repo   AuditRepository
    cache  TokenCache
    logger *zap.Logger
}

func NewAuditService(repo AuditRepository, cache TokenCache, logger *zap.Logger) *AuditService {
    return &AuditService{
        repo:   repo,
        cache:  cache,
        logger: logger,
    }
}
```

## Testing Patterns

### Unit Tests
```go
func TestAuditService_GetAuditLogs(t *testing.T) {
    tests := []struct {
        name    string
        setup   func(*mocks.MockRepository)
        want    *AuditResponse
        wantErr bool
    }{
        // test cases
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // test implementation
        })
    }
}
```

### Mock Generation
```bash
mockery --name=AuditRepository --output=mocks --outpkg=mocks
```

## Performance Optimizations

### HTTP Client Pooling
```go
&http.Client{
    Timeout: 30 * time.Second,
    Transport: &http.Transport{
        MaxIdleConns:        100,
        MaxIdleConnsPerHost: 10,
        IdleConnTimeout:     90 * time.Second,
    },
}
```

### Context Usage
- Always accept context as first parameter
- Set reasonable timeouts for external calls
- Check context cancellation in loops

### JSON Performance
- Use `json.RawMessage` for pass-through fields
- Pre-allocate slices when size is known
- Consider `easyjson` for hot paths (future)

## Security Considerations

### JWT Validation
- Validate signature with RS256 algorithm
- Check expiration time
- Verify issuer and audience claims
- Extract user ID from sub claim

### Input Validation
- Validate UUID format for sessionId
- Enforce pagination limits (max 100)
- Sanitize error messages
- No SQL injection (using REST API)

## Logging Standards

### Structured Fields
```go
logger.Info("audit logs retrieved",
    zap.String("request_id", requestID),
    zap.String("session_id", sessionID),
    zap.String("user_id", userID),
    zap.Int("count", count),
    zap.Duration("duration", duration),
)
```

### Log Levels
- Debug: Detailed flow information
- Info: Normal operations
- Warn: Recoverable issues
- Error: Failures requiring attention

## Configuration

### Environment Variables
- Use UPPER_SNAKE_CASE
- Provide defaults where sensible
- Document all variables in .env.example
- Validate required vars on startup

### Viper Setup
```go
viper.SetEnvPrefix("AUDIT")
viper.AutomaticEnv()
viper.SetDefault("PORT", "4006")
```

## API Response Format

### Success Response
```json
{
  "totalCount": 42,
  "items": [
    {
      "id": "uuid",
      "sessionId": "uuid",
      "userId": "uuid",
      "action": "edit",
      "timestamp": "2024-01-01T00:00:00Z",
      "details": {}
    }
  ]
}
```

### Error Response
```json
{
  "error": "forbidden",
  "message": "Access denied to this resource"
}
```

## Development Workflow

### Local Development
1. Copy `.env.example` to `.env`
2. Update Supabase credentials
3. Run `make run` or use `air` for hot reload
4. Test with `curl` or Postman

### Before Committing
1. Run `make lint` - fix any issues
2. Run `make test` - ensure all pass
3. Run `make docs` - update OpenAPI
4. Update memory bank if significant changes

---

*This file captures audit service-specific patterns and decisions.* 